
# 📘 기수 정렬 (Radix Sort) 상세 설명

---

## ✅ 1. 기수 정렬이란?

> **기수 정렬(Radix Sort)**은 **비교하지 않는 정렬 알고리즘**으로,  
자릿수별로 데이터를 분류하고 정렬하여 전체를 정렬하는 방식입니다.

- **비교 기반 아님** (데이터 값을 직접 비교하지 않음)
- 자릿수 단위로 정렬 (1의 자리 → 10의 자리 → 100의 자리 ...)
- **안정 정렬**

---

## ✅ 2. 정렬 방식 (LSD 방식 기준)

기수 정렬은 주로 두 가지 방식으로 구현됩니다:

| 방식 | 설명 |
|------|------|
| **LSD (Least Significant Digit)** | 낮은 자릿수부터 정렬 (1의 자리부터) |
| **MSD (Most Significant Digit)** | 높은 자릿수부터 정렬 (1000의 자리부터) |

> 일반적으로 **LSD 방식**이 널리 쓰이며, 배열로 쉽게 구현됩니다.

---

## ✅ 3. 작동 방식 예시

### 정렬 대상: `[170, 45, 75, 90, 802, 24, 2, 66]`

**Step 1: 1의 자리 정렬**
→ `[170, 90, 802, 2, 24, 45, 75, 66]`

**Step 2: 10의 자리 정렬**
→ `[802, 2, 24, 45, 66, 170, 75, 90]`

**Step 3: 100의 자리 정렬**
→ `[2, 24, 45, 66, 75, 90, 170, 802]` ✅ 정렬 완료

---

## ✅ 4. 시각화

```text
초기:         [170, 45, 75, 90, 802, 24, 2, 66]
1의 자리 →    [170, 90, 802, 2, 24, 45, 75, 66]
10의 자리 →   [802, 2, 24, 45, 66, 170, 75, 90]
100의 자리 →  [2, 24, 45, 66, 75, 90, 170, 802]
```

---

## ✅ 5. 기수 정렬 코드

### JavaScript

```javascript
function getMax(arr) {
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) max = arr[i];
  }
  return max;
}

function countingSort(arr, exp) {
  const output = new Array(arr.length).fill(0);
  const count = new Array(10).fill(0);

  for (let i = 0; i < arr.length; i++) {
    const index = Math.floor(arr[i] / exp) % 10;
    count[index]++;
  }

  for (let i = 1; i < 10; i++) count[i] += count[i - 1];

  for (let i = arr.length - 1; i >= 0; i--) {
    const index = Math.floor(arr[i] / exp) % 10;
    output[--count[index]] = arr[i];
  }

  for (let i = 0; i < arr.length; i++) arr[i] = output[i];
}

function radixSort(arr) {
  const max = getMax(arr);
  for (let exp = 1; Math.floor(max / exp) > 0; exp *= 10)
    countingSort(arr, exp);
  return arr;
}
```

---

## ✅ 6. 시간 복잡도

| 항목 | 설명 |
|------|------|
| **b**: 자릿수 | 예: 3자리 숫자 → b=3 |
| **n**: 데이터 개수 |
| **k**: 기수 (radix, 보통 10진법이면 10) |

- **시간 복잡도**: `O(b × (n + k))`
  - 고정 자릿수(b)가 작다면 거의 **O(n)**에 가까움

---

## ✅ 7. 공간 복잡도

- **O(n + k)**  
출력 배열과 카운트 배열 필요

---

## ✅ 8. 특징 요약

| 항목 | 설명 |
|------|------|
| 비교 기반 여부 | ❌ 아님 |
| 정렬 방식 | 자릿수 별로 정렬 |
| 안정 정렬 | ✅ |
| 정렬 조건 | 자릿수 고정, 음수 불가 (기본 구현) |
| 시간 복잡도 | O(nk) 또는 O(n log n) 수준 |
| 공간 복잡도 | O(n + k) |

---

## ✅ 9. 장점과 단점

### 장점

- 큰 수의 정렬 시 매우 빠름 (O(n) 수준)
- 비교 연산을 사용하지 않음
- 정렬 안정성이 있음

### 단점

- 음수 정렬 미지원 (추가 로직 필요)
- 데이터 형식 제한 (자릿수 정렬 가능한 데이터만)
- 추가 공간 필요

---

## ✅ 10. 기수 정렬 적합한 상황

| 조건 | 설명 |
|------|------|
| 데이터가 정수이고 자릿수 제한 있음 | 10진수 ID, ZIP 코드 등 |
| 빠른 정렬 필요 | 대규모 숫자 정렬 시 |
| 안정성이 중요한 경우 | 정렬 전 순서를 유지해야 할 때

---

## 🎯 마무리 요약

| 항목 | 설명 |
|------|------|
| 알고리즘 | 자릿수 정렬 방식 |
| 시간 복잡도 | O(b(n + k)) |
| 공간 복잡도 | O(n + k) |
| 정렬 안정성 | ✅ 있음 |
| 활용성 | ID, 우편번호, 정수 배열 등 |
