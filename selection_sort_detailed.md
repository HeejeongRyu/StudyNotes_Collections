
# 📘 선택 정렬 (Selection Sort) 상세 설명

---

## ✅ 1. 선택 정렬이란?

> **선택 정렬(Selection Sort)**은 **가장 작은(또는 큰) 데이터를 선택해서 앞쪽으로 차례차례 정렬**하는 방식의 정렬 알고리즘입니다.

- 정렬되지 않은 데이터 중에서 가장 작은 값을 찾아서 **앞쪽(또는 끝쪽)으로 이동**시킴
- 전체 데이터를 끝까지 반복하며 정렬
- 이름 그대로 **"선택"**해서 정렬

---

## ✅ 2. 동작 방식 (오름차순 기준)

1. 첫 번째 인덱스부터 시작해서, 나머지 중 **가장 작은 값의 인덱스를 찾음**
2. 그 값을 **현재 위치 값과 교환**
3. 다음 인덱스로 이동 후 **반복 수행**

### 🔹 예제: `[5, 3, 2, 4, 1]` 정렬 과정

| 단계 | 배열 상태 | 설명 |
|------|-----------|------|
| 초기 | `[5, 3, 2, 4, 1]` | 시작 |
| 1회전 | `[1, 3, 2, 4, 5]` | 0번에 가장 작은 1과 교환 |
| 2회전 | `[1, 2, 3, 4, 5]` | 1번에 가장 작은 2와 교환 |
| 3회전 | `[1, 2, 3, 4, 5]` | 2번에 가장 작은 3 이미 있음 |
| 4회전 | `[1, 2, 3, 4, 5]` | 3번에 4, 마지막 회전 |
| 완료 | `[1, 2, 3, 4, 5]` | 정렬 완료 |

---

## ✅ 3. 선택 정렬의 코드 예시

### 🔹 JavaScript

```javascript
function selectionSort(arr) {
  const n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    let minIndex = i;

    for (let j = i + 1; j < n; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }

    // swap
    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
  }
  return arr;
}

console.log(selectionSort([5, 3, 2, 4, 1]));
```

### 🔹 Java

```java
void selectionSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}
```

---

## ✅ 4. 시간 복잡도

| 상황 | 시간 복잡도 |
|------|--------------|
| 최선 | O(n²) |
| 평균 | O(n²) |
| 최악 | O(n²) |

- **비교 횟수**: 항상 `n(n-1)/2`
- **교환 횟수**: 버블 정렬보다 적음 (`n-1`회)

---

## ✅ 5. 공간 복잡도

- **O(1)** (추가 메모리 사용 없음 → 제자리 정렬 In-place Sort)

---

## ✅ 6. 특징 요약

| 항목 | 설명 |
|------|------|
| 정렬 방식 | 선택 → 교환 |
| 비교 횟수 | 많음 (버블정렬과 비슷) |
| 교환 횟수 | 상대적으로 적음 |
| 안정성 | **불안정 정렬** (같은 값의 순서가 바뀔 수 있음) |
| 메모리 사용 | 추가 메모리 없음 (In-place) |

---

## ✅ 7. 장점과 단점

### 🔹 장점

- 구현이 매우 간단함
- 교환 횟수가 적어서 **쓰기 비용이 큰 경우** 유리
- **In-place 알고리즘**

### 🔹 단점

- 시간 복잡도가 항상 O(n²) → 데이터가 많으면 비효율적
- 이미 정렬된 상태에서도 불필요한 비교 진행
- **실무에서는 거의 사용되지 않음**

---

## ✅ 8. 선택 정렬이 적합한 경우

| 경우 | 설명 |
|------|------|
| 학습용 | 정렬 알고리즘의 구조를 이해하는 데 적합 |
| 작은 데이터 정렬 | 리스트 길이가 짧을 경우 |
| 메모리가 매우 제한된 환경 | In-place 정렬이기 때문에 가능 |
| 쓰기 비용이 큰 저장장치 | 플래시 메모리 등에서는 교환이 적은 것이 유리함 |

---

## ✅ 9. 선택 정렬 시각화 (오름차순)

```text
초기:      [5, 3, 2, 4, 1]
↓
1회전:     [1, 3, 2, 4, 5]  ← 1을 맨 앞으로
2회전:     [1, 2, 3, 4, 5]  ← 2를 두 번째로
3회전:     [1, 2, 3, 4, 5]  ← 그대로
4회전:     [1, 2, 3, 4, 5]  ← 그대로
최종:      [1, 2, 3, 4, 5]
```

---

## 🎯 마무리 요약

| 항목 | 내용 |
|------|------|
| 기본 개념 | 가장 작은(또는 큰) 값을 선택해서 앞쪽에 위치 |
| 시간 복잡도 | O(n²) 항상 동일 |
| 공간 복잡도 | O(1), 제자리 정렬 |
| 정렬 안정성 | 불안정 정렬 |
| 사용 추천 | 소규모 데이터, 학습용, 쓰기 비용이 큰 환경 |
