
# 📘 퀵 정렬 (Quick Sort) 상세 설명

---

## ✅ 1. 퀵 정렬이란?

> **퀵 정렬(Quick Sort)**은 **기준값(피벗)**을 기준으로 **작은 값과 큰 값으로 나눈 뒤**, **재귀적으로 정렬**하는 분할 정복 알고리즘입니다.

- 평균적으로 **O(n log n)**의 성능
- **불안정 정렬** (동일 값의 순서가 바뀔 수 있음)
- 실무에서 가장 널리 사용되는 정렬 중 하나

---

## ✅ 2. 핵심 원리: **분할 정복(Divide and Conquer)**

### 📌 분할 정복 구조

1. **분할(Divide)**: 피벗 기준으로 작은 값 / 큰 값으로 나눔
2. **정복(Conquer)**: 나뉜 부분을 재귀적으로 정렬
3. **결합(Combine)**: 정렬된 하위 리스트를 병합 (퀵 정렬은 별도 병합 없음)

---

## ✅ 3. 작동 방식 (오름차순 기준)

1. **배열에서 피벗(Pivot)을 선택**
2. 피벗보다 작은 값은 **왼쪽**, 큰 값은 **오른쪽**으로 이동
3. 피벗을 기준으로 **좌/우 하위 배열을 재귀적으로 정렬**

---

## ✅ 4. 예시로 이해하기

### 🔹 정렬 대상: `[5, 3, 8, 4, 2, 7, 1, 6]`
피벗을 첫 번째 요소 `5`로 선택한 경우:

1. 분할 → `[3, 4, 2, 1]` + `5` + `[8, 7, 6]`
2. 왼쪽 정렬 → `[1, 2, 3, 4]`
3. 오른쪽 정렬 → `[6, 7, 8]`
4. 최종 결과 → `[1, 2, 3, 4, 5, 6, 7, 8]`

---

## ✅ 5. 퀵 정렬 시각화

```
[5, 3, 8, 4, 2, 7, 1, 6]
↓ pivot = 5
[3, 4, 2, 1] + 5 + [8, 7, 6]
↓ 재귀
[1, 2, 3, 4] + 5 + [6, 7, 8]
```

---

## ✅ 6. 퀵 정렬 코드 구현

### 🔹 JavaScript

```javascript
function quickSort(arr) {
  if (arr.length <= 1) return arr;

  const pivot = arr[0];
  const left = arr.slice(1).filter(x => x < pivot);
  const right = arr.slice(1).filter(x => x >= pivot);

  return [...quickSort(left), pivot, ...quickSort(right)];
}
```

### 🔹 Java (in-place)

```java
void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pivotIndex = partition(arr, low, high);
        quickSort(arr, low, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, high);
    }
}

int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;
        }
    }

    int temp = arr[i + 1]; arr[i + 1] = arr[high]; arr[high] = temp;
    return i + 1;
}
```

---

## ✅ 7. 시간 복잡도 분석

| 경우 | 시간 복잡도 | 설명 |
|------|--------------|------|
| 최선 | O(n log n) | 항상 균등하게 분할될 경우 |
| 평균 | O(n log n) | 일반적인 무작위 배열 |
| 최악 | O(n²) | 이미 정렬된 배열에 첫 원소를 피벗으로 선택한 경우 |

> 💡 최악의 경우를 피하려면 **중간값 피벗** 또는 **랜덤 피벗**을 선택하는 전략 사용

---

## ✅ 8. 공간 복잡도

- 일반적인 재귀 구현 시 **O(log n)** (호출 스택 공간)
- JavaScript의 경우 **slice**로 인해 O(n) 이상의 공간 사용

---

## ✅ 9. 퀵 정렬의 특징 정리

| 항목 | 설명 |
|------|------|
| 정렬 방식 | 분할 정복 (피벗 기준 분할) |
| 안정성 | ❌ 불안정 정렬 |
| 메모리 사용 | 보통 낮음, In-place 가능 |
| 빠른 정렬 | 평균적으로 매우 빠름 |
| 구현 난이도 | 중급 이상 (in-place는 복잡)

---

## ✅ 10. 장점과 단점

### 🔹 장점

- **빠른 정렬 속도** (특히 큰 배열에서 효율적)
- In-place 정렬 가능 (메모리 효율)
- 평균 O(n log n) 성능

### 🔹 단점

- 피벗 선택이 중요 → 잘못 선택하면 O(n²)
- **불안정 정렬**
- 재귀 호출로 인해 스택 오버플로우 가능성 존재

---

## ✅ 11. 최적화 전략

| 전략 | 설명 |
|------|------|
| 랜덤 피벗 선택 | 특정 입력에 대한 편향 방지 |
| 하이브리드 정렬 | 작은 부분배열은 삽입 정렬로 전환 |
| 테일 재귀 최적화 | 스택 깊이 줄이기 |

---

## ✅ 12. 퀵 정렬이 적합한 상황

| 상황 | 설명 |
|------|------|
| 대규모 정렬 | 배열이 클수록 효율 증가 |
| 메모리 제약 환경 | In-place 구현 시 유리 |
| 정렬 안정성이 필요 없는 경우 | 순서 바뀌는 게 상관 없을 때

---

## 🎯 마무리 요약

| 항목 | 설명 |
|------|------|
| 정렬 방식 | 분할 정복, 피벗 중심 |
| 시간 복잡도 | 평균 O(n log n), 최악 O(n²) |
| 공간 복잡도 | O(log n) (재귀 스택) |
| 정렬 안정성 | ❌ 불안정 |
| 실무 활용성 | ✅ 매우 높음 (기본 라이브러리에도 사용됨) |
