
# 📘 버블 정렬 (Bubble Sort) 상세 설명

---

## ✅ 1. 버블 정렬이란?

> **버블 정렬(Bubble Sort)**은 **인접한 두 요소를 비교해서 정렬하는 방식**의 알고리즘입니다.  
가장 큰 값이 매 반복마다 오른쪽 끝으로 이동하게 되어 마치 **"거품이 올라가는 것처럼"** 보인다고 해서 **Bubble Sort**라고 불립니다.

---

## ✅ 2. 동작 원리 (오름차순 기준)

1. 배열의 첫 번째 요소부터 시작하여 **인접한 두 값을 비교**
2. 앞의 값이 크면 **서로 위치를 교환**
3. 한 번의 패스(pass)마다 **가장 큰 값이 맨 끝으로 이동**
4. 마지막 요소를 제외한 부분에 대해 반복 수행

---

## ✅ 3. 예시로 이해하기

### 🔹 정렬 대상: `[5, 3, 2, 4, 1]`

| 패스 | 배열 상태 | 설명 |
|------|-----------|------|
| 1회전 | `[3, 2, 4, 1, 5]` | 5가 맨 끝으로 이동 |
| 2회전 | `[2, 3, 1, 4, 5]` | 4가 2번째 자리로 이동 |
| 3회전 | `[2, 1, 3, 4, 5]` | 3 자리 고정 |
| 4회전 | `[1, 2, 3, 4, 5]` | 정렬 완료 |

---

## ✅ 4. 버블 정렬 시각화

```text
초기:      [5, 3, 2, 4, 1]
↓
1회전:     [3, 2, 4, 1, 5]
2회전:     [2, 3, 1, 4, 5]
3회전:     [2, 1, 3, 4, 5]
4회전:     [1, 2, 3, 4, 5]
최종:      [1, 2, 3, 4, 5]
```

---

## ✅ 5. 버블 정렬의 코드 예시

### 🔹 JavaScript

```javascript
function bubbleSort(arr) {
  const n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}
```

### 🔹 Java

```java
void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

---

## ✅ 6. 최적화된 버블 정렬

```javascript
function optimizedBubbleSort(arr) {
  const n = arr.length;
  let swapped;
  for (let i = 0; i < n - 1; i++) {
    swapped = false;
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        swapped = true;
      }
    }
    if (!swapped) break;
  }
  return arr;
}
```

---

## ✅ 7. 시간 복잡도

| 상황 | 비교 횟수 | 시간 복잡도 |
|------|------------|-------------|
| 최악 | O(n²) | 역순 정렬 |
| 평균 | O(n²) | 무작위 정렬 |
| 최선 | O(n) | 이미 정렬된 상태 (최적화 버전에서만) |

---

## ✅ 8. 공간 복잡도

- **O(1)** (In-place 정렬)

---

## ✅ 9. 특징 정리

| 항목 | 내용 |
|------|------|
| 알고리즘 유형 | 비교 기반 정렬 |
| 정렬 안정성 | **안정 정렬** (동일 값의 순서 유지) |
| 메모리 | 추가 공간 없음 |
| 구현 난이도 | 매우 쉬움 |
| 실무 활용도 | 매우 낮음 (느린 성능) |

---

## ✅ 10. 장점과 단점

### 🔹 장점

- 매우 간단하고 직관적
- 구현 쉬움
- 안정 정렬 (같은 값 순서 유지)
- 정렬이 거의 완료된 배열에선 빠르게 종료 가능

### 🔹 단점

- 성능 매우 나쁨 (O(n²))
- 대규모 데이터에 부적합
- 최적화 없이는 쓸모 없음

---

## ✅ 11. 버블 정렬이 적합한 상황

| 상황 | 이유 |
|------|------|
| 초보 알고리즘 학습 | 구조가 단순하고 직관적 |
| 데이터가 매우 작을 때 | 구현이 쉬워서 빠르게 적용 가능 |
| 실시간으로 바뀌는 데이터의 정렬 상태 유지 | 단 하나의 변경만 반영하고 싶은 경우 |

---

## 🎯 마무리 요약

| 항목 | 설명 |
|------|------|
| 기본 개념 | 인접 요소를 비교하고 교환하며 정렬 |
| 시간 복잡도 | O(n²), 최적화 시 O(n) 가능 |
| 공간 복잡도 | O(1) |
| 안정성 | 안정 정렬 |
| 적합 용도 | 학습, 소규모 정렬, 단순한 상황 |
