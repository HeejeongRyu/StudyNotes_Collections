
# 📘 삽입 정렬 (Insertion Sort) 상세 설명

---

## ✅ 1. 삽입 정렬이란?

> **삽입 정렬(Insertion Sort)**은 배열을 순차적으로 훑으며, **현재 원소를 앞쪽에 있는 정렬된 구간의 적절한 위치에 삽입**하는 방식의 정렬 알고리즘입니다.

- 마치 **카드 게임에서 손에 하나씩 카드를 추가하면서 정렬하는 방식**과 유사
- 인플레이스(In-place) 정렬이며, 간단한 구현 가능

---

## ✅ 2. 작동 원리 (오름차순 기준)

1. **두 번째 요소부터 시작**
2. 현재 요소를 **앞쪽 정렬된 부분과 비교**
3. 적절한 위치까지 **뒤로 밀고 삽입**
4. 이 과정을 끝까지 반복

---

## ✅ 3. 예시로 이해하기

### 🔹 정렬 대상: `[5, 3, 2, 4, 1]`

| 단계 | 정렬 과정 | 설명 |
|------|-----------|------|
| 초기 | `[5, 3, 2, 4, 1]` | 초기 배열 |
| 1회전 | `[3, 5, 2, 4, 1]` | 3을 5 앞에 삽입 |
| 2회전 | `[2, 3, 5, 4, 1]` | 2를 3 앞에 삽입 |
| 3회전 | `[2, 3, 4, 5, 1]` | 4를 5 앞에 삽입 |
| 4회전 | `[1, 2, 3, 4, 5]` | 1을 맨 앞으로 삽입 |

---

## ✅ 4. 삽입 정렬 시각화

```text
초기:      [5, 3, 2, 4, 1]
↓
1회전:     [3, 5, 2, 4, 1]
2회전:     [2, 3, 5, 4, 1]
3회전:     [2, 3, 4, 5, 1]
4회전:     [1, 2, 3, 4, 5]
```

---

## ✅ 5. 삽입 정렬 코드 예시

### 🔹 JavaScript

```javascript
function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let current = arr[i];
    let j = i - 1;
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j]; // 뒤로 밀기
      j--;
    }
    arr[j + 1] = current; // 삽입
  }
  return arr;
}
```

### 🔹 Java

```java
void insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int current = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > current) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = current;
    }
}
```

---

## ✅ 6. 시간 복잡도

| 상황 | 시간 복잡도 | 설명 |
|------|--------------|------|
| 최선 | O(n) | 이미 정렬된 배열 |
| 평균 | O(n²) | 일반적인 경우 |
| 최악 | O(n²) | 역순으로 정렬된 배열 |

---

## ✅ 7. 공간 복잡도

- **O(1)** (In-place 정렬, 추가 메모리 사용 없음)

---

## ✅ 8. 특징 요약

| 항목 | 설명 |
|------|------|
| 정렬 방식 | 삽입 |
| 안정성 | ✅ **안정 정렬** |
| 비교 기반 정렬 | ✅ |
| 메모리 | 추가 공간 필요 없음 |
| 구현 난이도 | 매우 쉬움 |

---

## ✅ 9. 장점과 단점

### 🔹 장점

- 구현이 간단
- 데이터가 거의 정렬되어 있는 경우 **매우 빠름 (O(n))**
- 안정 정렬 (같은 값의 순서 유지)
- 메모리 사용 최소화

### 🔹 단점

- 데이터가 많으면 느림 (O(n²))
- 효율성 낮음 → 대규모 정렬에는 적합하지 않음

---

## ✅ 10. 삽입 정렬이 적합한 경우

| 상황 | 설명 |
|------|------|
| 소규모 배열 | 작고 간단한 정렬 |
| 거의 정렬된 데이터 | O(n)으로 빠르게 동작 |
| 온라인 정렬 | 실시간으로 데이터를 정렬해야 할 경우 |
| 안정 정렬이 필요한 경우 | 동일한 값의 순서를 유지해야 하는 경우 |

---

## 🎯 마무리 요약

| 항목 | 설명 |
|------|------|
| 알고리즘 | 삽입 방식의 정렬 |
| 시간 복잡도 | O(n²), 정렬된 상태 O(n) |
| 공간 복잡도 | O(1) |
| 안정성 | ✅ 안정 정렬 |
| 사용 적합 | 소규모 데이터, 거의 정렬된 배열, 온라인 정렬 |
