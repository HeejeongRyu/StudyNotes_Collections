# Oracle Full Table Scan vs Index Full Scan

## 🔎 Full Table Scan (FTS)
- **무엇을 스캔하나?** 👉 테이블 세그먼트 전체(데이터 블록)
- **읽는 방식** 👉 멀티블록 I/O로 한 번에 여러 블록씩 순차적으로 읽음
- **정렬 보장 여부** 👉 없음 (물리적 저장 순서일 뿐)
- **언제 쓰이나?**
  - 조건이 거의 없거나 조건에 맞는 행이 대부분일 때 (선택도 낮음)
  - 인덱스를 써도 랜덤 액세스 비용이 더 클 때
  - 작은 테이블 (수백 건 수준)
- **장점**
  - 병렬화·멀티블록 읽기로 대량 처리 빠름
- **단점**
  - 행 수가 많으면 불필요한 I/O 발생

---

## 🔎 Index Full Scan (IFS)
- **무엇을 스캔하나?** 👉 인덱스 세그먼트 전체
- **읽는 방식** 👉 루트 → 브랜치 → 리프 블록 체인을 따라 **한 블록씩 순서대로** 읽음 (싱글블록 I/O)
- **정렬 보장 여부** 👉 **있음** (인덱스 키 컬럼 순서 보장)
- **언제 쓰이나?**
  - ORDER BY, GROUP BY 최적화에 인덱스 정렬을 활용할 때
  - WHERE 조건이 넓지만 필요한 컬럼이 인덱스에 다 들어 있을 때 (covering index)
  - 옵티마이저가 테이블 풀 스캔보다 낫다고 판단할 때
- **장점**
  - 정렬 비용 없음 (ORDER BY 불필요)
- **단점**
  - 싱글블록 I/O라 대량 처리 시 FTS보다 느림

---

## 📊 비교 요약

| 항목 | Full Table Scan (FTS) | Index Full Scan (IFS) |
|------|-------------------------|--------------------------|
| 대상 | **테이블** 전체 | **인덱스** 전체 |
| I/O 방식 | **멀티블록 I/O** | **싱글블록 I/O** |
| 정렬 보장 | ❌ 없음 | ✅ 인덱스 키 순서 보장 |
| 활용 목적 | 대량 데이터 처리 | ORDER BY, 인덱스-온리 |
| 속도 특성 | 대량 읽기 최적 | 정렬 비용 절감, 좁은 컬럼 |

---

## 📌 예시

```sql
-- Full Table Scan 예시
SELECT COUNT(*) FROM sales;
-- 조건 없음 → 전체 테이블 읽음 → FTS

-- Index Full Scan 예시
SELECT order_date FROM sales ORDER BY order_date;
-- 인덱스(order_date) 있으면 IFS → 정렬 작업 불필요
```

---

👉 **정리**  
- **FTS** = 테이블 블록 전체를 “덩어리”로 읽음 (빠른 대량 읽기).  
- **IFS** = 인덱스 블록 전체를 “순서대로” 읽음 (정렬 보장, 하지만 블록 I/O 효율은 낮음).
